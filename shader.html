<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tremble's Pebbles – Orbit to G Formation</title>
  <style>
    @font-face {
      font-family: 'FutoSansHeavy';
      src: url('https://gabledatavisual.blob.core.windows.net/data/futo-sans-heavy.ttf') format('truetype');
    }
    body {
      margin: 0;
      overflow: hidden;
      position: relative;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
  <canvas id="ballCanvas"></canvas>
  <script>
    // ------ Background Shader (unchanged) ------
    let scene, camera, renderer, planes = [];
    initBackground();
    animateBackground();
    
    function initBackground() {
      scene = new THREE.Scene();
      camera = new THREE.Camera();
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      renderer.domElement.style.position = 'fixed';
      renderer.domElement.style.top = '0';
      renderer.domElement.style.left = '0';
      renderer.domElement.style.zIndex = '-1';

      const fragmentShader = `
          precision mediump float;
          uniform float iTime;
          uniform vec2 iResolution;
          
          vec3 mod289(vec3 x) {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
          }
          vec2 mod289(vec2 x) {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
          }
          vec3 permute(vec3 x) {
              return mod289(((x*34.0)+1.0)*x);
          }
          float snoise(vec2 v){
              const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                                  -0.577350269189626, 0.024390243902439);
              vec2 i  = floor(v + dot(v, C.yy) );
              vec2 x0 = v - i + dot(i, C.xx);
              vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
              vec4 x12 = x0.xyxy + C.xxzz;
              x12.xy -= i1;
              i = mod289(i);
              vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                + i.x + vec3(0.0, i1.x, 1.0 ));
              vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
              m = m*m;
              m = m*m;
              vec3 x = 2.0 * fract(p * C.www) - 1.0;
              vec3 h = abs(x) - 0.5;
              vec3 ox = floor(x + 0.5);
              vec3 a0 = x - ox;
              m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
              vec3 g;
              g.x  = a0.x  * x0.x + h.x  * x0.y;
              g.yz = a0.yz * x12.xz + h.yz * x12.yw;
              return 130.0 * dot(m, g);
          }
          
          void mainImage( out vec4 fragColor, in vec2 fragCoord )
          {
              vec2 uv = fragCoord / iResolution.xy;
              float n = snoise(uv * 10.0 + iTime * 0.5);
              float shimmer = sin(iTime + uv.x * 10.0) * 0.5 + 0.5;
              
              vec3 color1 = vec3(0.611765, 0.262745, 0.996078);
              vec3 color2 = vec3(0.298039, 0.760784, 0.913725);
              vec3 color3 = vec3(0.062745, 0.078431, 0.600000);
              
              vec3 col = mix(color1, color2, uv.y + n * 0.3);
              col = mix(col, color3, uv.x + shimmer * 0.3);
              
              fragColor = vec4(col, 1.0);
          }
          
          void main() {
              mainImage(gl_FragColor, gl_FragCoord.xy);
          }
      `;

      let geometry = new THREE.PlaneBufferGeometry(2, 2);
      let material = new THREE.ShaderMaterial({
        uniforms: {
          iTime: { value: 0 },
          iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        },
        fragmentShader: fragmentShader,
        transparent: false
      });
      let plane = new THREE.Mesh(geometry, material);
      scene.add(plane);
      planes.push({ mesh: plane, material: material });
      window.addEventListener('resize', onWindowResize, false);
    }
    function onWindowResize() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      planes.forEach(planeObj => {
        planeObj.material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
      });
    }
    function animateBackground() {
      requestAnimationFrame(animateBackground);
      planes.forEach(planeObj => {
        planeObj.material.uniforms.iTime.value += 0.01;
      });
      renderer.render(scene, camera);
    }
    
    // ------ Balls & G-Formation Animation ------
    const canvas = document.getElementById('ballCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Settings for scaling and orbiting
    const MIN_DIAMETER = 15;
    const MAX_DIAMETER = 3000;
    const MIN_AMOUNT = 1;
    const MAX_AMOUNT = 5000000;
    const DATE_RANGE = 30;
    const SPEED_FACTORS = [20, 18, 14, 9, 8, 5, 2, 1];
    const TARGET_RADIUS = 7; // Uniform radius when in "G" formation

    const balls = [];
    let targetPositions = []; // Array to hold positions from the text "G"
    // Slightly smaller orbit radius so they’re closer to center
    const orbitRadius = Math.min(canvas.width, canvas.height) / 3;

    // Helper: Generate a random color that remains fixed for each ball.
    function randomColor() {
      const r = Math.floor(Math.random() * 256);
      const g = Math.floor(Math.random() * 256);
      const b = Math.floor(Math.random() * 256);
      return `rgb(${r},${g},${b})`;
    }

    // Ball class – stores orbit position and target position.
    class Ball {
      constructor(diameter, speedFactor, orbitAngle) {
        this.diameter = diameter;
        this.radius = diameter / 2;
        this.orbitAngle = orbitAngle;
        // Orbit radius: random factor between 80% and 120% of the new orbitRadius
        this.orbitRadius = orbitRadius * (0.8 + Math.random() * 0.4);
        this.orbitSpeed = speedFactor * 0.001;
        this.color = randomColor();
        // Current orbit position (updated each frame)
        this.x = 0;
        this.y = 0;
        // Target “G” position (assigned later)
        this.targetX = canvas.width / 2;
        this.targetY = canvas.height / 2;
        this.targetRadius = TARGET_RADIUS;
      }
      update() {
        this.orbitAngle += this.orbitSpeed;
        if (this.orbitAngle >= 2 * Math.PI) {
          this.orbitAngle -= 2 * Math.PI;
        }
        this.x = canvas.width / 2 + this.orbitRadius * Math.cos(this.orbitAngle);
        this.y = canvas.height / 2 + this.orbitRadius * Math.sin(this.orbitAngle);
      }
    }

    // Compute target positions by drawing a “G” offscreen, then bounding-box centering.
    function computeTargetPositions() {
      const offCanvas = document.createElement('canvas');
      offCanvas.width = 300;
      offCanvas.height = 300;
      const offCtx = offCanvas.getContext('2d');

      // Fill with black so "white" stands out
      offCtx.fillStyle = "black";
      offCtx.fillRect(0, 0, offCanvas.width, offCanvas.height);

      // Slightly smaller font than before so we don’t clip edges
      offCtx.font = "bold 150px FutoSansHeavy, Arial, sans-serif";
      offCtx.textAlign = "center";
      offCtx.textBaseline = "middle";
      offCtx.fillStyle = "white";
      offCtx.fillText("G", offCanvas.width / 2, offCanvas.height / 2);

      const imageData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height).data;
      const positions = [];
      const step = 2; // sample every 2 pixels
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;

      // Collect all white pixels and track bounding box
      for (let y = 0; y < offCanvas.height; y += step) {
        for (let x = 0; x < offCanvas.width; x += step) {
          const idx = (y * offCanvas.width + x) * 4;
          const alpha = imageData[idx + 3];
          if (alpha > 128) {
            positions.push({ x, y });
            if (x < minX) minX = x;
            if (x > maxX) maxX = x;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
          }
        }
      }

      // Compute bounding box size
      const letterWidth = maxX - minX;
      const letterHeight = maxY - minY;

      // We'll center that bounding box on the main canvas
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      // The top-left corner of that bounding box should be:
      //   (centerX - letterWidth/2, centerY - letterHeight/2)
      // So each pixel offset is:
      //   finalX = (x - minX) + (centerX - letterWidth/2)
      //   finalY = (y - minY) + (centerY - letterHeight/2)
      const offsetX = centerX - letterWidth / 2;
      const offsetY = centerY - letterHeight / 2;

      const finalPositions = positions.map(pos => {
        return {
          x: (pos.x - minX) + offsetX,
          y: (pos.y - minY) + offsetY
        };
      });

      return finalPositions;
    }

    // Load data from the XLSX and create balls.
    function loadBallsFromData(data) {
      const today = new Date();
      balls.length = 0;
      data.forEach(record => {
        try {
          const excelDate = record['OpenOrder[OrderDate]'];
          const date = new Date((excelDate - 25569) * 86400 * 1000);
          const daysOld = Math.floor((today.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));
          if (daysOld > DATE_RANGE) return;

          const amountField = record['[SumOrderTotal]'];
          if (typeof amountField !== 'number') return;
          const amount = amountField;
          if (isNaN(amount) || amount < 1) return;
          // Linear scaling of diameter based on amount
          const diameter = MIN_DIAMETER + ((amount - MIN_AMOUNT) / (MAX_AMOUNT - MIN_AMOUNT)) * (MAX_DIAMETER - MIN_DIAMETER);
          const speedFactor = SPEED_FACTORS[Math.min(daysOld, DATE_RANGE)];
          const orbitAngle = Math.random() * 2 * Math.PI;
          const ball = new Ball(diameter, speedFactor, orbitAngle);
          balls.push(ball);
        } catch (e) {
          console.error("Error processing record: ", record, e);
        }
      });
      // After loading balls, compute target positions from the letter "G"
      targetPositions = computeTargetPositions();
      // Assign each ball a target position (cycle through if needed)
      balls.forEach((ball, i) => {
        const pos = targetPositions[i % targetPositions.length];
        ball.targetX = pos.x;
        ball.targetY = pos.y;
        ball.targetRadius = TARGET_RADIUS;
      });
    }

    // Animation loop for the balls.
    function animateBalls() {
      // Compute a blend factor that oscillates over a period (6 sec full cycle)
      const now = performance.now() / 1000;
      const period = 6.0;
      const t = (now % period) / period;
      let blend = 0;
      if (t < 0.25) {
        blend = t / 0.25; // blend increases from 0 to 1 over first 25%
      } else if (t < 0.5) {
        blend = 1; // hold formation for next 25%
      } else if (t < 0.75) {
        blend = 1 - ((t - 0.5) / 0.25); // blend back to orbit state
      } else {
        blend = 0;
      }
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // (Optional) If you want to show the static "G" behind them, uncomment:
      /*
      ctx.font = "bold 100px FutoSansHeavy, Arial, sans-serif";
      ctx.fillStyle = "black";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.shadowBlur = 10;
      ctx.shadowColor = "rgba(100, 149, 237, 2.5)";
      ctx.fillText("G", canvas.width / 2, canvas.height / 2);
      ctx.shadowBlur = 0;
      */

      // Update and draw each ball with positions and sizes interpolated based on blend.
      balls.forEach(ball => {
        ball.update();
        // Interpolate between orbit (ball.x, ball.y, ball.radius) and target (ball.targetX, ball.targetY, TARGET_RADIUS)
        const currentX = (1 - blend) * ball.x + blend * ball.targetX;
        const currentY = (1 - blend) * ball.y + blend * ball.targetY;
        const currentRadius = (1 - blend) * ball.radius + blend * ball.targetRadius;
        ctx.beginPath();
        ctx.fillStyle = ball.color;
        ctx.arc(currentX, currentY, currentRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
      });
      requestAnimationFrame(animateBalls);
    }

    // Data refresh functions (unchanged except that loadBallsFromData now sets target positions)
    function refreshData() {
      fetch('https://gabledatavisual.blob.core.windows.net/data/pebbles.xlsx')
        .then(response => {
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          return response.arrayBuffer();
        })
        .then(data => {
          const workbook = XLSX.read(data, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[sheetName];
          const jsonData = XLSX.utils.sheet_to_json(worksheet);
          loadBallsFromData(jsonData);
        })
        .catch(error => console.error('Error fetching XLSX:', error));
    }
    window.onload = () => {
      fetch('https://gabledatavisual.blob.core.windows.net/data/pebbles.xlsx')
        .then(response => {
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          return response.arrayBuffer();
        })
        .then(data => {
          const workbook = XLSX.read(data, { type: 'array' });
          const sheetName = workbook.SheetNames[0];
          const worksheet = workbook.Sheets[sheetName];
          const jsonData = XLSX.utils.sheet_to_json(worksheet);
          loadBallsFromData(jsonData);
          animateBalls();
        })
        .catch(error => console.error('Error fetching XLSX:', error));

      setInterval(refreshData, 60 * 60 * 1000);
    };

    // (Optional) Handle canvas resize – re‑compute the target positions so the "G" remains centered.
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (targetPositions.length > 0) {
        targetPositions = computeTargetPositions();
        balls.forEach((ball, i) => {
          const pos = targetPositions[i % targetPositions.length];
          ball.targetX = pos.x;
          ball.targetY = pos.y;
        });
      }
    });
  </script>
</body>
</html>
