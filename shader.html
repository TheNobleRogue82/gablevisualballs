<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tremble's Pebbles with WebGL Background</title>
  <style>
    @font-face {
      font-family: 'FutoSansHeavy';
      src: url('https://gabledatavisual.blob.core.windows.net/data/futo-sans-heavy.ttf') format('truetype');
    }
    body {
      margin: 0;
      overflow: hidden;
      position: relative;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
  <canvas id="ballCanvas"></canvas>
  <script>
    let scene, camera, renderer, planes = [];

    initBackground();
    animateBackground();
    initBalls();

    function initBackground() {
      // Set up the scene
      scene = new THREE.Scene();
      camera = new THREE.Camera();

      // Set up renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      renderer.domElement.style.position = 'fixed';
      renderer.domElement.style.top = '0';
      renderer.domElement.style.left = '0';
      renderer.domElement.style.zIndex = '-1';

      // Flowy, shimmering background shader that fills the window
      const fragmentShader = `
          precision mediump float;
          uniform float iTime;
          uniform vec2 iResolution;
          
          // 2D simplex noise function
          vec3 mod289(vec3 x) {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
          }
          vec2 mod289(vec2 x) {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
          }
          vec3 permute(vec3 x) {
              return mod289(((x*34.0)+1.0)*x);
          }
          float snoise(vec2 v){
              const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                                  -0.577350269189626, 0.024390243902439);
              vec2 i  = floor(v + dot(v, C.yy) );
              vec2 x0 = v - i + dot(i, C.xx);
              vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
              vec4 x12 = x0.xyxy + C.xxzz;
              x12.xy -= i1;
              i = mod289(i);
              vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                + i.x + vec3(0.0, i1.x, 1.0 ));
              vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
              m = m*m;
              m = m*m;
              vec3 x = 2.0 * fract(p * C.www) - 1.0;
              vec3 h = abs(x) - 0.5;
              vec3 ox = floor(x + 0.5);
              vec3 a0 = x - ox;
              m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
              vec3 g;
              g.x  = a0.x  * x0.x + h.x  * x0.y;
              g.yz = a0.yz * x12.xz + h.yz * x12.yw;
              return 130.0 * dot(m, g);
          }
          
          void mainImage( out vec4 fragColor, in vec2 fragCoord )
          {
              vec2 uv = fragCoord / iResolution.xy;
              // Create a swirling noise pattern
              float n = snoise(uv * 10.0 + iTime * 0.5);
              // Shimmer effect based on time and x-coordinate
              float shimmer = sin(iTime + uv.x * 10.0) * 0.5 + 0.5;
              
              // Define colors
              vec3 color1 = vec3(0.611765, 0.262745, 0.996078);
              vec3 color2 = vec3(0.298039, 0.760784, 0.913725);
              vec3 color3 = vec3(0.062745, 0.078431, 0.600000);
              
              // Blend colors using the vertical coordinate and noise
              vec3 col = mix(color1, color2, uv.y + n * 0.3);
              // Mix in horizontal variation with the shimmer effect
              col = mix(col, color3, uv.x + shimmer * 0.3);
              
              fragColor = vec4(col, 1.0);
          }
          
          void main() {
              mainImage(gl_FragColor, gl_FragCoord.xy);
          }
      `;

      // Create a single full-screen plane for the background
      let geometry = new THREE.PlaneBufferGeometry(2, 2);
      let material = new THREE.ShaderMaterial({
        uniforms: {
          iTime: { value: 0 },
          iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        },
        fragmentShader: fragmentShader,
        transparent: false
      });

      let plane = new THREE.Mesh(geometry, material);
      scene.add(plane);
      planes.push({ mesh: plane, material: material });

      // Handle window resize
      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      planes.forEach(planeObj => {
        planeObj.material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
      });
    }

    function animateBackground() {
      requestAnimationFrame(animateBackground);
      planes.forEach(planeObj => {
        planeObj.material.uniforms.iTime.value += 0.01;
      });
      renderer.render(scene, camera);
    }

    function initBalls() {
      const canvas = document.getElementById('ballCanvas');
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // Updated ball size settings for linear scaling:
      // Smallest ball: 50px; largest (amount=5,000,000): 1000px.
      const MIN_DIAMETER = 15;
      const MAX_DIAMETER = 3000;
      const MIN_AMOUNT = 1;
      const MAX_AMOUNT = 5000000;
      const DATE_RANGE = 30;
      const SPEED_FACTORS = [20, 18, 14, 9, 8, 5, 2, 1];
      const balls = [];

      // Increase orbit radius so balls are further from the center
      const orbitRadius = Math.min(canvas.width, canvas.height) / 2;

      // Define the Ball class
      class Ball {
        constructor(diameter, speedFactor, orbitAngle) {
          this.diameter = diameter;
          this.radius = diameter / 2;
          this.orbitAngle = orbitAngle;
          // Orbit further away from center: between 80% and 120% of orbitRadius
          this.orbitRadius = orbitRadius * (0.8 + Math.random() * 0.4);
          this.orbitSpeed = speedFactor * 0.001;
          this.brightness = 50;
        }

        update() {
          this.orbitAngle += this.orbitSpeed;
          if (this.orbitAngle >= 2 * Math.PI) {
            this.orbitAngle -= 2 * Math.PI;
          }
          this.x = canvas.width / 2 + this.orbitRadius * Math.cos(this.orbitAngle);
          this.y = canvas.height / 2 + this.orbitRadius * Math.sin(this.orbitAngle);
        }

        draw() {
          if (isFinite(this.x) && isFinite(this.y) && isFinite(this.radius)) {
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();

            ctx.shadowBlur = 20;
            ctx.shadowColor = `rgba(100, 149, 237, 0.7)`;
            ctx.fill();
            ctx.shadowBlur = 0;

            const gradient = ctx.createRadialGradient(this.x, this.y, this.radius * 0.85, this.x, this.y, this.radius);
            gradient.addColorStop(0, 'rgba(100, 150, 255, 0)');
            gradient.addColorStop(1, 'rgba(50, 100, 237, 0.7)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
          }
        }
      }

      function loadBallsFromData(data) {
        const today = new Date();
        data.forEach(record => {
          try {
            const excelDate = record['OpenOrder[OrderDate]'];
            const date = new Date((excelDate - 25569) * 86400 * 1000);
            const daysOld = Math.floor((today.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));
            if (daysOld > DATE_RANGE) {
              return;
            }

            const amountField = record['[SumOrderTotal]'];
            if (typeof amountField !== 'number') {
              return;
            }
            const amount = amountField;
            if (isNaN(amount) || amount < 1) {
              return;
            }
            // Linear scaling of diameter based on amount from MIN_AMOUNT to MAX_AMOUNT:
            const diameter = MIN_DIAMETER + ((amount - MIN_AMOUNT) / (MAX_AMOUNT - MIN_AMOUNT)) * (MAX_DIAMETER - MIN_DIAMETER);
            const speedFactor = SPEED_FACTORS[Math.min(daysOld, DATE_RANGE)];
            const orbitAngle = Math.random() * 2 * Math.PI;
            const brightness = 100 - (daysOld * (100 / DATE_RANGE));

            const ball = new Ball(diameter, speedFactor, orbitAngle);
            ball.brightness = brightness;
            balls.push(ball);
          } catch (e) {
            console.error("Error processing record: ", record, e);
          }
        });
      }

      function animateBalls() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.font = "bold 100px FutoSansHeavy, Arial, sans-serif";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.shadowBlur = 10;
        ctx.shadowColor = "rgba(100, 149, 237, 2.5)";
        ctx.fillText("G", canvas.width / 2, canvas.height / 2);
        ctx.shadowBlur = 0;

        balls.forEach(ball => {
          ball.update();
          ball.draw();
        });
        requestAnimationFrame(animateBalls);
      }

      function refreshData() {
        fetch('https://gabledatavisual.blob.core.windows.net/data/pebbles.xlsx')
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.arrayBuffer();
          })
          .then(data => {
            const workbook = XLSX.read(data, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(worksheet);
            balls.length = 0;
            loadBallsFromData(jsonData);
          })
          .catch(error => console.error('Error fetching XLSX:', error));
      }

      window.onload = () => {
        fetch('https://gabledatavisual.blob.core.windows.net/data/pebbles.xlsx')
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.arrayBuffer();
          })
          .then(data => {
            const workbook = XLSX.read(data, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(worksheet);
            loadBallsFromData(jsonData);
            animateBalls();
          })
          .catch(error => console.error('Error fetching XLSX:', error));

        setInterval(refreshData, 60 * 60 * 1000);
      };
    }
  </script>
</body>
</html>
