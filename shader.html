<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tremble's Pebbles – Orbit to G Formation</title>
  <style>
    @font-face {
      font-family: 'FutoSansHeavy';
      src: url('https://gabledatavisual.blob.core.windows.net/data/futo-sans-heavy.ttf') format('truetype');
    }
    body {
      margin: 0;
      overflow: hidden;
      position: relative;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
  <canvas id="ballCanvas"></canvas>
  <script>
    // ------ Background Shader (unchanged) ------
    let scene, camera, renderer, planes = [];
    initBackground();
    animateBackground();
    
    function initBackground() {
      scene = new THREE.Scene();
      camera = new THREE.Camera();
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      renderer.domElement.style.position = 'fixed';
      renderer.domElement.style.top = '0';
      renderer.domElement.style.left = '0';
      renderer.domElement.style.zIndex = '-1';

      const fragmentShader = `
          precision mediump float;
          uniform float iTime;
          uniform vec2 iResolution;
          
          vec3 mod289(vec3 x) {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
          }
          vec2 mod289(vec2 x) {
              return x - floor(x * (1.0 / 289.0)) * 289.0;
          }
          vec3 permute(vec3 x) {
              return mod289(((x*34.0)+1.0)*x);
          }
          float snoise(vec2 v){
              const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                                  -0.577350269189626, 0.024390243902439);
              vec2 i  = floor(v + dot(v, C.yy) );
              vec2 x0 = v - i + dot(i, C.xx);
              vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
              vec4 x12 = x0.xyxy + C.xxzz;
              x12.xy -= i1;
              i = mod289(i);
              vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
                + i.x + vec3(0.0, i1.x, 1.0 ));
              vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
              m = m*m;
              m = m*m;
              vec3 x = 2.0 * fract(p * C.www) - 1.0;
              vec3 h = abs(x) - 0.5;
              vec3 ox = floor(x + 0.5);
              vec3 a0 = x - ox;
              m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
              vec3 g;
              g.x  = a0.x  * x0.x + h.x  * x0.y;
              g.yz = a0.yz * x12.xz + h.yz * x12.yw;
              return 130.0 * dot(m, g);
          }
          
          void mainImage( out vec4 fragColor, in vec2 fragCoord )
          {
              vec2 uv = fragCoord / iResolution.xy;
              float n = snoise(uv * 10.0 + iTime * 0.5);
              float shimmer = sin(iTime + uv.x * 10.0) * 0.5 + 0.5;
              
              vec3 color1 = vec3(0.611765, 0.262745, 0.996078);
              vec3 color2 = vec3(0.298039, 0.760784, 0.913725);
              vec3 color3 = vec3(0.062745, 0.078431, 0.600000);
              
              vec3 col = mix(color1, color2, uv.y + n * 0.3);
              col = mix(col, color3, uv.x + shimmer * 0.3);
              
              fragColor = vec4(col, 1.0);
          }
          
          void main() {
              mainImage(gl_FragColor, gl_FragCoord.xy);
          }
      `;

      let geometry = new THREE.PlaneBufferGeometry(2, 2);
      let material = new THREE.ShaderMaterial({
        uniforms: {
          iTime: { value: 0 },
          iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
        },
        fragmentShader: fragmentShader,
        transparent: false
      });
      let plane = new THREE.Mesh(geometry, material);
      scene.add(plane);
      planes.push({ mesh: plane, material: material });
      window.addEventListener('resize', onWindowResize, false);
    }
    function onWindowResize() {
      renderer.setSize(window.innerWidth, window.innerHeight);
      planes.forEach(planeObj => {
        planeObj.material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
      });
    }
    function animateBackground() {
      requestAnimationFrame(animateBackground);
      planes.forEach(planeObj => {
        planeObj.material.uniforms.iTime.value += 0.01;
      });
      renderer.render(scene, camera);
    }
    
    // ------ Balls & G-Formation Animation ------
    const canvas = document.getElementById('ballCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Settings for scaling and orbiting
    const MIN_DIAMETER = 15;
    const MAX_DIAMETER = 3000;
    const MIN_AMOUNT = 1;
    const MAX_AMOUNT = 5000000;
    const DATE_RANGE = 30;
    const SPEED_FACTORS = [20, 18, 14, 9, 8, 5, 2, 1];
    const TARGET_RADIUS = 7; // Uniform radius when in "G" formation

    const balls = [];
    let targetPositions = []; // Array to hold positions from the text "G"
    // Slightly smaller orbit radius so they’re closer to center
    const orbitRadius = Math.min(canvas.width, canvas.height) / 3;

    // Helper: Generate a random color that remains fixed for each ball.
    function randomColor() {
      const r = Math.floor(Math.random() * 256);
      const g = Math.floor(Math.random() * 256);
      const b = Math.floor(Math.random() * 256);
      return `rgb(${r},${g},${b})`;
    }

    // Ball class – stores orbit position and target position.
    class Ball {
      constructor(diameter, speedFactor, orbitAngle) {
        this.diameter = diameter;
        this.radius = diameter / 2;
        this.orbitAngle = orbitAngle;
        // Orbit radius: random factor between 80% and 120% of the new orbitRadius
        this.orbitRadius = orbitRadius * (0.8 + Math.random() * 0.4);
        this.orbitSpeed = speedFactor * 0.001;
        this.color = randomColor();
        // Current orbit position (updated each frame)
        this.x = 0;
        this.y = 0;
        // Target “G” position (assigned later)
        this.targetX = canvas.width / 2;
        this.targetY = canvas.height / 2;
        this.targetRadius = TARGET_RADIUS;
      }
      update() {
        this.orbitAngle += this.orbitSpeed;
        if (this.orbitAngle >= 2 * Math.PI) {
          this.orbitAngle -= 2 * Math.PI;
        }
        this.x = canvas.width / 2 + this.orbitRadius * Math.cos(this.orbitAngle);
        this.y = canvas.height / 2 + this.orbitRadius * Math.sin(this.orbitAngle);
      }
    }

    // Compute target positions by drawing a “G” offscreen, then bounding-box centering.
    function computeTargetPositions() {
      const offCanvas = document.createElement('canvas');
      offCanvas.width = 300;
      offCanvas.height = 300;
      const offCtx = offCanvas.getContext('2d');

      // Fill with black so "white" stands out
      offCtx.fillStyle = "black";
      offCtx.fillRect(0, 0, offCanvas.width, offCanvas.height);

      // Slightly smaller font than before so we don’t clip edges
      offCtx.font = "bold 150px FutoSansHeavy, Arial, sans-serif";
      offCtx.textAlign = "center";
      offCtx.textBaseline = "middle";
      offCtx.fillStyle = "white";
      offCtx.fillText("G", offCanvas.width / 2, offCanvas.height / 2);

      const imageData = offCtx.getImageData(0, 0, offCanvas.width, offCanvas.height).data;
      const
