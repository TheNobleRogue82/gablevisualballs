<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Shader Multiple Halos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">
    <script>
        let scene, camera, renderer, material, planes = [];

        init();
        animate();

        function init() {
            // Set up the scene
            scene = new THREE.Scene();
            camera = new THREE.Camera();

            // Set up renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Set up multiple halos with different sizes
            const fragmentShader = `
                uniform float iTime;
                uniform vec2 iResolution;
                
                vec3 hash33(vec3 p3) {
                    p3 = fract(p3 * vec3(.1031, .11369, .13787));
                    p3 += dot(p3, p3.yxz + 19.19);
                    return -1.0 + 2.0 * fract(vec3(p3.x + p3.y, p3.x + p3.z, p3.y + p3.z) * p3.zyx);
                }
                
                float snoise3(vec3 p) {
                    const float K1 = 0.333333333;
                    const float K2 = 0.166666667;
                    
                    vec3 i = floor(p + (p.x + p.y + p.z) * K1);
                    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);
                    
                    vec3 e = step(vec3(0.0), d0 - d0.yzx);
                    vec3 i1 = e * (1.0 - e.zxy);
                    vec3 i2 = 1.0 - e.zxy * (1.0 - e);
                    
                    vec3 d1 = d0 - (i1 - K2);
                    vec3 d2 = d0 - (i2 - K1);
                    vec3 d3 = d0 - 0.5;
                    
                    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);
                    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));
                    
                    return dot(vec4(31.316), n);
                }
                
                vec4 extractAlpha(vec3 colorIn) {
                    vec4 colorOut;
                    float maxValue = min(max(max(colorIn.r, colorIn.g), colorIn.b), 1.0);
                    if (maxValue > 1e-5) {
                        colorOut.rgb = colorIn.rgb * (1.0 / maxValue);
                        colorOut.a = maxValue;
                    } else {
                        colorOut = vec4(0.0);
                    }
                    return colorOut;
                }
                
                #define BG_COLOR (vec3(sin(iTime) * 0.5 + 0.5) * 0.0 + vec3(0.0))
                #define time iTime
                const vec3 color1 = vec3(0.611765, 0.262745, 0.996078);
                const vec3 color2 = vec3(0.298039, 0.760784, 0.913725);
                const vec3 color3 = vec3(0.062745, 0.078431, 0.600000);
                const float innerRadius = 0.6;
                const float noiseScale = 0.65;
                
                void mainImage(out vec4 fragColor, in vec2 fragCoord) {
                    vec2 uv = (fragCoord * 2.0 - iResolution) / iResolution.y;
                    
                    float ang = atan(uv.y, uv.x);
                    float len = length(uv);
                    float n0 = snoise3(vec3(uv * noiseScale, time * 0.5)) * 0.5 + 0.5;
                    float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);
                    float d0 = distance(uv, r0 / len * uv);
                    float v0 = 1.0 / (1.0 + d0 * 10.0);
                    v0 *= smoothstep(r0 * 1.05, r0, len);
                    float cl = cos(ang + time * 2.0) * 0.5 + 0.5;
                    
                    vec3 col = mix(color3, mix(color1, color2, cl), v0);
                    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
                }
                
                void main() {
                    mainImage(gl_FragColor, gl_FragCoord.xy);
                }
            `;

            // Create multiple planes for different halos
            for (let i = 0; i < 3; i++) {
                let geometry = new THREE.PlaneBufferGeometry(2 + i, 2 + i);
                let material = new THREE.ShaderMaterial({
                    uniforms: {
                        iTime: { value: 0 },
                        iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                    },
                    fragmentShader: fragmentShader,
                    transparent: true
                });

                let plane = new THREE.Mesh(geometry, material);
                plane.position.z = -i * 0.1; // Slightly offset each plane in the z-axis
                scene.add(plane);
                planes.push({ mesh: plane, material: material });
            }

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            planes.forEach(planeObj => {
                planeObj.material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            planes.forEach(planeObj => {
                planeObj.material.uniforms.iTime.value += 0.01;
            });
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
