<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Shader Ring</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">
    <script>
        let scene, camera, renderer, material, plane, balls = [];

        init();
        animate();

        function init() {
            // Set up the scene
            scene = new THREE.Scene();
            camera = new THREE.Camera();

            // Set up renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Set up the geometry and material
            const geometry = new THREE.PlaneBufferGeometry(2, 2);
            const fragmentShader = `
                uniform float iTime;
                uniform vec2 iResolution;
                
                vec3 hash33(vec3 p3) {
                    p3 = fract(p3 * vec3(.1031, .11369, .13787));
                    p3 += dot(p3, p3.yxz + 19.19);
                    return -1.0 + 2.0 * fract(vec3(p3.x + p3.y, p3.x + p3.z, p3.y + p3.z) * p3.zyx);
                }
                
                float snoise3(vec3 p) {
                    const float K1 = 0.333333333;
                    const float K2 = 0.166666667;
                    
                    vec3 i = floor(p + (p.x + p.y + p.z) * K1);
                    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);
                    
                    vec3 e = step(vec3(0.0), d0 - d0.yzx);
                    vec3 i1 = e * (1.0 - e.zxy);
                    vec3 i2 = 1.0 - e.zxy * (1.0 - e);
                    
                    vec3 d1 = d0 - (i1 - K2);
                    vec3 d2 = d0 - (i2 - K1);
                    vec3 d3 = d0 - 0.5;
                    
                    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);
                    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));
                    
                    return dot(vec4(31.316), n);
                }
                
                vec4 extractAlpha(vec3 colorIn) {
                    vec4 colorOut;
                    float maxValue = min(max(max(colorIn.r, colorIn.g), colorIn.b), 1.0);
                    if (maxValue > 1e-5) {
                        colorOut.rgb = colorIn.rgb * (1.0 / maxValue);
                        colorOut.a = maxValue;
                    } else {
                        colorOut = vec4(0.0);
                    }
                    return colorOut;
                }
                
                #define BG_COLOR (vec3(sin(iTime) * 0.5 + 0.5) * 0.0 + vec3(0.0))
                #define time iTime
                const vec3 color1 = vec3(0.611765, 0.262745, 0.996078);
                const vec3 color2 = vec3(0.298039, 0.760784, 0.913725);
                const vec3 color3 = vec3(0.062745, 0.078431, 0.600000);
                const float innerRadius = 0.6;
                const float noiseScale = 0.65;
                
                void mainImage(out vec4 fragColor, in vec2 fragCoord) {
                    vec2 uv = (fragCoord * 2.0 - iResolution) / iResolution.y;
                    
                    float ang = atan(uv.y, uv.x);
                    float len = length(uv);
                    float n0 = snoise3(vec3(uv * noiseScale, time * 0.5)) * 0.5 + 0.5;
                    float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);
                    float d0 = distance(uv, r0 / len * uv);
                    float v0 = 1.0 / (1.0 + d0 * 10.0);
                    v0 *= smoothstep(r0 * 1.05, r0, len);
                    float cl = cos(ang + time * 2.0) * 0.5 + 0.5;
                    
                    vec3 col = mix(color3, mix(color1, color2, cl), v0);
                    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
                }
                
                void main() {
                    mainImage(gl_FragColor, gl_FragCoord.xy);
                }
            `;
            
            material = new THREE.ShaderMaterial({
                uniforms: {
                    iTime: { value: 0 },
                    iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) }
                },
                fragmentShader: fragmentShader
            });

            plane = new THREE.Mesh(geometry, material);
            scene.add(plane);

            // Add bouncing balls
            const ballGeometry = new THREE.SphereGeometry(1, 32, 32);
            const ballMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const numBalls = 10;
            for (let i = 0; i < numBalls; i++) {
                let ball = new THREE.Mesh(ballGeometry, ballMaterial);
                ball.position.set(
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4,
                    (Math.random() - 0.5) * 4
                );
                ball.scale.setScalar(Math.random() * 2);
                ball.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02
                );
                scene.add(ball);
                balls.push(ball);
            }

            // Add light
            const light = new THREE.PointLight(0xffffff, 1);
            light.position.set(0, 0, 5);
            scene.add(light);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.iResolution.value.set(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.iTime.value += 0.01;

            // Update ball positions
            balls.forEach(ball => {
                ball.position.add(ball.userData.velocity);

                // Check for collisions with bounds and reverse velocity if necessary
                if (Math.abs(ball.position.x) > 2) ball.userData.velocity.x *= -1;
                if (Math.abs(ball.position.y) > 2) ball.userData.velocity.y *= -1;
                if (Math.abs(ball.position.z) > 2) ball.userData.velocity.z *= -1;
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
